// RobotBuilder Version: 0.0.2
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
package org.usfirst.frc.team2471.robot.commands;
import org.usfirst.frc.team2471.robot.Polar;
import org.usfirst.frc.team2471.robot.Robot;
import org.usfirst.frc.team2471.robot.RobotMap;

import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.Preferences;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
/**
 *
 */
public class  DriveLoop extends Command {
    
	double prevAngle = 0.0;
    double prevTime = 0.0;
    public static Preferences prefin;
    
    public DriveLoop() {
        // Use requires() here to declare subsystem dependencies
        // eg. requires(chassis);
        SmartDashboard.putNumber("Tote Speed", 1.0);
        SmartDashboard.putNumber("RC Speed" , 0.7);
        SmartDashboard.putNumber("Tote Pivot", 10);
    	SmartDashboard.putNumber("RC Pivot", -22);
    	
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(RobotMap.swerve);
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    }
    // Called just before this Command runs the first time
    protected void initialize() {
    	
    }
    // Called repeatedly when this Command is scheduled to run
    protected void execute() {
        double x =  Robot.oi.driverStick.getAxis(Joystick.AxisType.kX);
        double y = -Robot.oi.driverStick.getAxis(Joystick.AxisType.kY);  // odd, but up is negative
        double r =  Robot.oi.driverStick.getAxis(Joystick.AxisType.kZ);
        double x2 = Robot.oi.coStick.getAxis(Joystick.AxisType.kX);
        double y2 = -Robot.oi.coStick.getAxis(Joystick.AxisType.kY);  // odd, but up is negative
        double r2 =  Robot.oi.coStick.getRawAxis(4);
//        double s = -Robot.oi.driverStick.getAxis(Joystick.AxisType.kThrottle);  // kThrottle is the y of the right stick
//        double s2 = -Robot.oi.coStick.getAxis(Joystick.AxisType.kThrottle);
        double speedBinMag = Math.sqrt(x2 * x2 + y2 * y2);
        double speedToteMag = Math.sqrt((x * x + y * y));
        
        // Bin driver dead bands for sloppy MS controller
        if (speedBinMag < 0.10){
        	x2 = y2 = 0.0;
        }
        if (Math.abs(r2) < 0.10)
        	r2 = 0.0;
        
        double gyroAngle = -RobotMap.gyro.getAngle() * (Math.PI/180.0);
//        double gyroAngle = -RobotMap.compass.getAngle() * (Math.PI/180.0);
        double accelX = 0;//RobotMap.accel.getAcceleration(ADXL345_I2C.Axes.kX);
        double accelY = 0;//RobotMap.accel.getAcceleration(ADXL345_I2C.Axes.kY);
        double accelZ = 0;//RobotMap.accel.getAcceleration(ADXL345_I2C.Axes.kZ);
        double time = Timer.getFPGATimestamp();
        double turnSpeed = (gyroAngle - prevAngle)/(time - prevTime);
        prevTime = time;
        prevAngle = gyroAngle;
//        SmartDashboard.putNumber("Turn Speed", turnSpeed);
        
        boolean fieldMove = SmartDashboard.getBoolean("FieldMove", true);
//        boolean fieldSteer = SmartDashboard.getBoolean("FieldSteer", false);
       
        double speedBin = SmartDashboard.getNumber("RC Speed");
        double speedTote = SmartDashboard.getNumber("Tote Speed");
        
        double speedSum = speedBin*speedBinMag + speedTote*speedToteMag;
        if (speedSum > 1.0){
        	speedBin /= speedSum;
            speedTote /= speedSum;
        }
        
	    if (fieldMove)
	    {
	        Polar polar = new Polar(x,y);   // convert strafe to polar
	        
	        SmartDashboard.putNumber("Joystick Angle", -polar.GetAngle());
	        SmartDashboard.putNumber("gyroAngle", -gyroAngle);
	        
	        polar.AddAngle( -gyroAngle );  // add gyro to convert the strafe request from field to robot space
	
	        x = polar.GetX();  // convert back to rectangular, so we can blend with Can Driver's robot based requests
	        y = polar.GetY();
	    }
	    
        double refinedX = (x * speedTote) + (-x2 * speedBin);
        double refinedY = (y * speedTote) + (-y2 * speedBin);
        double refinedR = (r * speedTote) + (r2 * speedBin);
//        double refinedS = (s * speedTote) + (-s2 * speedBin);
        
        // blended mix of pivot locations
        double turnScale1 = Math.abs(r);
        double turnScale2 = Math.abs(r2);
        double turnSum = turnScale1 + turnScale2;
        if (turnSum > 0.0)  // someone wants to turn, this way total weight for pivots is always 1.0
        {
        	turnScale1 /= turnSum;
        	turnScale2 /= turnSum;
            double yPivot = turnScale1 * SmartDashboard.getNumber("Tote Pivot") + turnScale2 * SmartDashboard.getNumber("RC Pivot");
            RobotMap.swerve.setYPivot(yPivot);
        }
        
        // call drive, indicate field move false, since we already did that computation
       RobotMap.swerve.drive(-refinedX,-refinedY,-refinedR,0.0,gyroAngle,accelX,accelY, false, turnSpeed, false, false, false);
    }

    // Make this return true when this Command no longer needs to run execute()
    protected boolean isFinished() {
        return false;
    }
    // Called once after isFinished returns true
    protected void end() {
    }
    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    protected void interrupted() {
    }
    
    public static double TurnSpeed(){
    	double time = Timer.getFPGATimestamp();
    	double gyroAngle = -RobotMap.gyro.getAngle() * (Math.PI/180.0);
    	double prevTime = 0.0;
        double prevAngle = 0.0;
		double turnSpeed = (gyroAngle - prevAngle)/(time - prevTime);
    	return turnSpeed;
    	
    }
}
